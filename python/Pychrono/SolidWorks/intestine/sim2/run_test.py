def main():
    pass


if __name__ == '__main__':
    main()

import os
import math
import time
import sys, getopt
import pychrono as chrono
import pychrono.postprocess as postprocess
import pychrono.irrlicht as chronoirr
import numpy as np
import objects as ob

# ----------------------------------------------------------------------
#
# Control methods: simplex, comparison, local_alignment
control_method = 'local_alignment'

# ---------------------------------------------------------------------
#
# Parse command-line parameters

m_filename = "Sim.py"
m_timestep = 0.01
m_length = 1.0
m_visualization = "irrlicht"
m_datapath = "C:/Chrono/Chrono_builds/Chrono-develop/bin/data/"
try:
    opts, args = getopt.getopt(sys.argv[1:], "f:d:T:v:p:",
                               ["filename=", "timestep=", "Tlength=", "visualization=", "datapath="])
except getopt.GetoptError:
    # print ("run_test.py -f <filename> [-d <timestep> -T <length> -v <pov|irrlicht> -p <chronodatapath>]")
    sys.exit(2)
for opt, arg in opts:
    print("opt:", opt, "  arg", arg)
    if opt in ("-d", "--timestep"):
        m_timestep = float(arg)
    elif opt in ("-T", "--Tlength"):
        m_length = float(arg)
    elif opt in ("-f", "--filename"):
        m_filename = arg
    elif opt in ("-v", "--visualization"):
        m_visualization = arg
    elif opt in ("-p", "--datapath"):
        m_datapath = arg

if m_filename == "":
    print("run_test.py -f <filename> [-d <timestep> -T <length> -v <pov|irrlicht> -p <chronodatapath>]")
    sys.exit(2)

if not os.path.isfile(m_filename):
    print("Error. Filename " + m_filename + " does not exist.")
    sys.exit(2)

chrono.SetChronoDataPath(m_datapath)

print("  file to load is ", m_filename)
print("  timestep is ", m_timestep)
print("  length is ", m_length)
print("  data path for fonts etc.: ", m_datapath)

# ---------------------------------------------------------------------
#
#  load the file generated by the SolidWorks CAD plugin
#  and add it to the ChSystem.
#

# Remove the trailing .py and add / in case of file without ./
m_absfilename = os.path.abspath(m_filename)
m_modulename = os.path.splitext(m_absfilename)[0]

print("Loading C::E scene...")

exported_items = chrono.ImportSolidWorksSystem(m_modulename)

print("...loading done!")

# Print exported items
for my_item in exported_items:
    print(my_item.GetName())

# Add items to the physical system
my_system = chrono.ChSystemNSC()
for my_item in exported_items:
    my_system.Add(my_item)

# Optionally set some solver parameters.

# my_system.SetMaxPenetrationRecoverySpeed(1.00)
my_system.SetSolverType(chrono.ChSolver.Type_PSSOR);
# my_system.SetMaxItersSolverSpeed(600);
# my_system.SetSolverWarmStarting(True);
my_system.Set_G_acc(chrono.ChVectorD(0, -0.981, 0))


# Material definition

mu_f = .3  # friction
mu_b = 0.1  # dampning
mu_r = .4  # rolling friction
mu_s = .01  # SPinning fiction

Ct = .00001 #Shear compliance
C = .00001  #Bending complince
Cr = .0001  #Rolling complince
Cs = .0001  #Spinning compliance

material = chrono.ChMaterialSurfaceNSC()
material.SetFriction(mu_f)
material.SetDampingF(mu_b)
material.SetCompliance(C)
material.SetComplianceT(Ct)
material.SetRollingFriction(mu_r)
material.SetSpinningFriction(mu_s)
material.SetComplianceRolling(Cr)
material.SetComplianceSpinning(Cs)

material2 = chrono.ChMaterialSurfaceNSC()
material2.SetFriction(0.8)
material2.SetDampingF(0.01)
material2.SetCompliance(C)
material2.SetComplianceT(Ct)
material2.SetRollingFriction(mu_r)
material2.SetSpinningFriction(mu_s)
material2.SetComplianceRolling(Cr)
material2.SetComplianceSpinning(Cs)

material3 = chrono.ChMaterialSurfaceNSC()
material3.SetFriction(0.2)
material3.SetDampingF(0)
material3.SetCompliance(C)
material3.SetComplianceT(Ct)
material3.SetRollingFriction(mu_r)
material3.SetSpinningFriction(mu_s)
material3.SetComplianceRolling(Cr)
material3.SetComplianceSpinning(Cs)

my_object = my_system.SearchBody('object-1')
if not my_object:
    sys.exit('Error: cannot find object from its name in the C::E system!')
mboxtexture = chrono.ChTexture()
mboxtexture.SetTextureFilename(chrono.GetChronoDataPath() + 'blu.png')
my_object.GetAssets().push_back(mboxtexture)

object_marker = my_object.SearchMarker('object_marker')
if not object_marker:
    sys.exit('Error: cannot find object marker from its name in the C::E system!')

ground_marker = my_system.SearchMarker('ground_marker')
if not ground_marker:
    sys.exit('Error: cannot find ground marker from its name in the C::E system!')

my_ground = my_system.SearchBody('graound-1')
if not my_ground:
    sys.exit('Error: cannot find ground from its name in the C::E system!')

my_ground.SetMaterialSurface(material)

my_shaft = {}
my_leg = {}
my_marker = {}
my_link = {}
link_motor = {}
revolute_frame = {}
redMaker = {}
marker_xaxis = {}

for i in range(1, 13):
    my_shaft[str(i-1)] = my_system.SearchBody('robo_leg_link-' + str(i) + '/single_bot1-1')
    if not my_shaft[str(i-1)]:
        sys.exit('Error: cannot find shaft  from its name in the C::E system!')
    my_link[str(i-1)] = my_system.SearchBody('robo_leg_link-' + str(i) + '/link1-1')
    if not my_link[str(i-1)]:
        sys.exit('Error: cannot find link  from its name in the C::E system!')
    my_marker[str(i-1)] = my_shaft[str(i-1)].SearchMarker('My_marker')
    if not my_marker[str(i-1)]:
        sys.exit('Error: cannot find marker from its name in the C::E system!')
    my_leg[str(i-1)] = my_system.SearchBody('robo_leg_link-' + str(i) + '/leg-1')
    if not my_leg[str(i-1)]:
        sys.exit('Error: cannot find leg from its name in the C::E system!')
    revolute_frame[str(i-1)] = my_marker[str(i-1)].GetAbsFrame()
    link_motor[str(i-1)] = chrono.ChLinkMotorRotationSpeed()
    link_motor[str(i-1)].Initialize(my_leg[str(i-1)], my_shaft[str(i-1)], revolute_frame[str(i-1)])
    link_motor[str(i-1)].SetSpindleConstraint(chrono.ChLinkMotorRotationSpeed.SpindleConstraint_CYLINDRICAL)
    link_motor[str(i-1)].SetMotorFunction(chrono.ChFunction_Const(5 * chrono.CH_C_2PI))  # 1.0 Hz to rad/s
    my_system.Add(link_motor[str(i-1)])
    my_shaft[str(i-1)].SetMaterialSurface(material3)
    my_leg[str(i-1)].SetMaterialSurface(material2)

    redMaker[str(i-1)] = chrono.ChBodyEasySphere(0.015,
                                      0.00001,
                                      False,
                                      True)
    redMaker[str(i-1)].SetPos(my_marker[str(i-1)].GetAbsFrame().GetPos())
    redMaker[str(i-1)].SetRot(my_marker[str(i-1)].GetAbsFrame().GetRot())
    redMaker[str(i - 1)].SetMass(1)
    marker_xaxis[str(i-1)] = chrono.ChMarker()
    marker_xaxis[str(i-1)].SetName('redMaker-'+str(i-1))
    redMaker[str(i-1)].AddMarker(marker_xaxis[str(i-1)])
    marker_xaxis[str(i-1)].Impose_Abs_Coord(chrono.ChCoordsysD(my_marker[str(i-1)].GetAbsFrame().GetPos(), my_marker[str(i-1)].GetAbsFrame().GetRot()))
    col = chrono.ChColorAsset()
    col.SetColor(chrono.ChColor(1, 0, 1))
    col.SetFading(1)
    redMaker[str(i-1)].AddAsset(col)
    my_system.Add(redMaker[str(i-1)])
    link_xaxis = chrono.ChLinkMateFix()
    link_xaxis.Initialize(redMaker[str(i-1)], my_shaft[str(i-1)])
    # link_xaxis.Initialize(marker_xaxis, my_marker)
    my_system.Add(link_xaxis)


my_robot = ob.InitRobot(12, my_marker, object_marker, control_method)


def run(state_values):
    for i in range(0, 12):
        link_motor[str(i)].SetMotorFunction(chrono.ChFunction_Const(state_values[i]*5 * chrono.CH_C_2PI))  # 1.0 Hz to rad/s
        if state_values[i] == 1:
            redMaker[str(i)].SetPos(chrono.ChVectorD(my_marker[str(i)].GetAbsFrame().GetPos().x, 0.05, my_marker[str(i)].GetAbsFrame().GetPos().z))
            my_leg[str(i)].SetMaterialSurface(material2)
        elif state_values[i] == -1:
            redMaker[str(i)].SetPos(chrono.ChVectorD(my_marker[str(i)].GetAbsFrame().GetPos().x, 0.05, my_marker[str(i)].GetAbsFrame().GetPos().z))
            my_leg[str(i)].SetMaterialSurface(material2)
        elif state_values[i] == 0:
            redMaker[str(i)].SetPos(chrono.ChVectorD(my_marker[str(i)].GetAbsFrame().GetPos().x, 0.12, my_marker[str(i)].GetAbsFrame().GetPos().z))
            my_leg[str(i)].SetMaterialSurface(material3)

if m_visualization == "irrlicht":

    # ---------------------------------------------------------------------
    #
    #  Create an Irrlicht application to visualize the system
    #

    myapplication = chronoirr.ChIrrApp(my_system, 'run_test', chronoirr.dimension2du(1600, 1200))
    myapplication.AddTypicalSky(chrono.GetChronoDataPath() + 'skybox/')
    myapplication.AddTypicalLights()
    myapplication.AddTypicalLogo(chrono.GetChronoDataPath() + 'logo_pychrono_alpha.png')
    myapplication.AddTypicalCamera(chronoirr.vector3df(5, 1.5, -4), chronoirr.vector3df(2.0, 0.02, 2.0))
    myapplication.AddLightWithShadow(chronoirr.vector3df(2, 5, 2), chronoirr.vector3df(2, 2, 2), 10, 2, 10, 120)
    # myapplication.AddLightWithShadow(chronoirr.vector3df(10,20,10),chronoirr.vector3df(0,2.6,0), 10 ,10,40, 60, 512);
    myapplication.SetSymbolscale(0.01)
    myapplication.SetShowInfos(True)
    myapplication.SetContactsDrawMode(3)
    myapplication.SetPaused(True)

    # ==IMPORTANT!== Use this function for adding a ChIrrNodeAsset to all items
    # in the system. These ChIrrNodeAsset assets are 'proxies' to the Irrlicht meshes.
    # If you need a finer control on which item really needs a visualization proxy in
    # Irrlicht, just use application.AssetBind(myitem); on a per-item basis.

    myapplication.AssetBindAll();

    # ==IMPORTANT!== Use this function for 'converting' into Irrlicht meshes the assets
    # that you added to the bodies into 3D shapes, they can be visualized by Irrlicht!

    myapplication.AssetUpdateAll();

    # ==IMPORTANT!== Use this function for enabling cast soft shadows

    myapplication.AddShadowAll();

    # ---------------------------------------------------------------------
    #
    #  Run the simulation forever until windows is closed
    #

    myapplication.SetTimestep(m_timestep);
    count = 0
    while (myapplication.GetDevice().run()):
        myapplication.BeginScene()
        myapplication.DrawAll()
        count = count + 1
        my_robot.marker = my_marker
        my_robot.extract_data()
        states = my_robot.controller()
        run(states)
        if my_robot.force < my_robot.num_of_robots*my_robot.K and np.min(my_robot.dist) > 0.2:
            my_robot.K = 0.6
            my_robot.control_method = 'stear'
            print('aligning- K:', my_robot.force/12)
        elif np.min(my_robot.dist) > 0.2:
            my_robot.control_method = 'comparison'
            my_robot.t_a = 45
            my_robot.K = 0.5
            print('moving- K:', my_robot.force/12)
        else:
            my_robot.control_method = 'engulfing'
            print('engulfing')
        if count > 500:
            my_object.SetPos(chrono.ChVectorD(2, my_object.GetPos().y, -0.5))
            my_robot.goal = object_marker
        if count > 3000:
            my_object.SetPos(chrono.ChVectorD(3, my_object.GetPos().y, -1))
            my_robot.goal = object_marker
        if count > 6000:
            my_object.SetPos(chrono.ChVectorD(2, my_object.GetPos().y, -2))
            my_robot.goal = object_marker
        # print('res:', res)
        # print('Robot#', i)
        # print('x:', d1.x)
        # print('z:', d1.z)
        # print('q:', q)
        myapplication.DoStep()
        myapplication.EndScene()
        my_robot.save_data()
    A = my_robot.get_data()




