#-------------------------------------------------------------------------------
# Name:        	run_diff_path.py
# Purpose:	Path controller for differential drive robot
#
# Author:      	Qiyuan Zhou
#-------------------------------------------------------------------------------
#!/usr/bin/env python







def main():
    pass

if __name__ == '__main__':
    main()


import os
import math
import time
import sys, getopt
import pychrono as chrono
import pychrono.postprocess as postprocess
import pychrono.irrlicht as chronoirr
import numpy as np

import matplotlib.pyplot as plt
from scipy.optimize import fsolve
from scipy.spatial import distance
from scipy.interpolate import Rbf
from scipy.interpolate import RegularGridInterpolator
import random
from mpl_toolkits.mplot3d import Axes3D
from matplotlib import cm 
import scipy.constants 



class Path:
    def __init__(self,x,y):
        
        # parameter representation of the curve
        x, y = map(np.asarray, (x, y))
        s = np.append([0],(np.cumsum(np.diff(x)**2) + np.cumsum(np.diff(y)**2))**0.5)
        
        # spline
        self.X = interpolate.CubicSpline(s, x)
        self.Y = interpolate.CubicSpline(s, y)
        
        self.dX = self.X.derivative(1)
        self.ddX = self.X.derivative(2)

        self.dY = self.Y.derivative(1)
        self.ddY = self.Y.derivative(2)
        self.length = s[-1]
        
# orientation
    def calc_yaw(self, s):
        dx, dy = self.dX(s), self.dY(s)
        yaw=np.arctan2(dy, dx)
        return yaw
    
# curvature    
    def calc_curvature(self, s):
        dx, dy   = self.dX(s), self.dY(s)
        ddx, ddy   = self.ddX(s), self.ddY(s)
        kp=(ddy * dx - ddx * dy) / ((dx ** 2 + dy ** 2)**(3 / 2))
        return kp

# Find point nearest 
    def __find_nearest_point(self, s0, x, y):
        def calc_distance(_s, *args):
            _x, _y= self.X(_s), self.Y(_s)
            return (_x - args[0])**2 + (_y - args[1])**2
        
        def calc_distance_jacobian(_s, *args):
            _x, _y = self.X(_s), self.Y(_s)
            _dx, _dy = self.dX(_s), self.dY(_s)
            return 2*_dx*(_x - args[0])+2*_dy*(_y-args[1])

        minimum = scipy.optimize.fmin_cg(calc_distance, s0, calc_distance_jacobian, args=(x, y), full_output=True, disp=False)
        
        return minimum  
    
    def calc_track_error(self, x, y, s0):
        # find nearest point
        ret = self.__find_nearest_point(s0, x, y)

        
        # s value that gives point P 
        s = ret[0][0]
        
        # distance from point P
        e = ret[1]

        # curvature
        k   = self.calc_curvature(s)
        # heading angle 
        yaw_ref = self.calc_yaw(s)
        
        dxl = self.X(s) - x
        dyl = self.Y(s) - y
        # error between the path and robot
        angle = pi_2_pi(yaw_ref - math.atan2(dyl, dxl))
        
        # if its negative flip it to positive 
        if angle < 0:
            e*= -1

        return e, k, yaw_ref, s    
















# ---------------------------------------------------------------------
# Parse command-line parameters

m_filename = "diff.py"
m_timestep = 0.001
m_length = 1.0
m_visualization = "irrlicht"
m_datapath = "C:/Program Files/ChronoSolidworks/data/"

#try:
#	opts, args = getopt.getopt(sys.argv[1:],"f:d:T:v:p:",["filename=","timestep=","Tlength=","visualization=","datapath="])
#except getopt.GetoptError:
#	#print ("run_test.py -f <filename> [-d <timestep> -T <length> -v <pov|irrlicht> -p <chronodatapath>]")
#	sys.exit(2)
#for opt, arg in opts:
#	print ("opt:", opt, "  arg", arg)
#	if   opt in ("-d", "--timestep"):
#		m_timestep = float(arg)
#	elif opt in ("-T", "--Tlength"):
#		m_length = float(arg)
#	elif opt in ("-f", "--filename"):
#		m_filename = arg
#	elif opt in ("-v", "--visualization"):
#		m_visualization = arg
#	elif opt in ("-p", "--datapath"):
#		m_datapath = arg
#		
#if m_filename == "":
#	print ("run_test.py -f <filename> [-d <timestep> -T <length> -v <pov|irrlicht> -p <chronodatapath>]")
#	sys.exit(2)
#
#if not os.path.isfile(m_filename):
#	print ("Error. Filename " + m_filename + " does not exist.")
#	sys.exit(2)
    
chrono.SetChronoDataPath(m_datapath)

print ("  file to load is ", m_filename)
print ("  timestep is ", m_timestep)
print ("  length is ", m_length)
print ("  data path for fonts etc.: ", m_datapath)
# ---------------------------------------------------------------------
#
#  load the file generated by the SolidWorks CAD plugin
#  and add it to the ChSystem.
#

# Remove the trailing .py and add / in case of file without ./
m_absfilename = os.path.abspath(m_filename)
m_modulename = os.path.splitext(m_absfilename)[0]
#print ("Loading C::E scene...");
exported_items = chrono.ImportSolidWorksSystem(m_modulename)
#print ("...loading done!");

# Print exported items
#for my_item in exported_items:
#	print (my_item.GetName())

# Add items to the physical system
my_system = chrono.ChSystemNSC()
# Colors
col_y = chrono.ChColorAsset()
col_y.SetColor(chrono.ChColor(0.44, .11, 52))
exported_items[1].AddAsset(col_y)

for my_item in exported_items:
	my_system.Add(my_item)
		
# Optionally set some solver parameters.
#timestepper = chrono.ChTimestepperEulerImplicitProjected()
my_system.SetSolverTolerance(1e-10)
my_solver = chrono.ChSolverBB()
my_system.SetSolver(my_solver)
my_solver.SetMaxIterations(200)
my_system.SetTimestepperType(1) # Euler Implicit Projected
my_solver.EnableWarmStart(True);
my_system.Set_G_acc(chrono.ChVectorD(0,-9.81,0))
chrono.ChCollisionModel_SetDefaultSuggestedEnvelope(0.001)
chrono.ChCollisionModel_SetDefaultSuggestedMargin(0.001)

# Default Material
material = chrono.ChMaterialSurfaceNSC()
material.SetFriction(0.4)
material.SetDampingF(0.)
material.SetCompliance(0.00001)

# Tire Material
tire_mat = chrono.ChMaterialSurfaceNSC()
tire_mat.SetFriction(0.8)
tire_mat.SetDampingF(0.)
tire_mat.SetCompliance(0.00001)

# Empty vectors to store wheel, torque, marker objects
right_wheels = []
left_wheels = []

right_torques = []
left_torques = []

right_markers = []
left_markers = []

bot_numbers = [1,4,5,7,8]   # Thanks stupid naming scheme in Solidworks

# Bot 1
bot1 = my_system.SearchBody('_bot-1')
wheel_left = my_system.SearchBody('wheel-1')
wheel_right = my_system.SearchBody('wheel-2')
bot1.AddAsset(col_y)
reference = bot1.SearchMarker('right_marker')
#random_noise = chrono.ChForce()
#bot1.AddForce(random_noise)
#random_noise.SetMode(chrono.ChForce.FORCE)

if not wheel_left or not wheel_right:
    sys.exit('Error: cannot find wheel from its name in the C::E system!')
    
left_torque = chrono.ChForce()
wheel_left.AddForce(left_torque)
left_torque.SetMode(chrono.ChForce.TORQUE)
left_torque.SetRelDir(chrono.ChVectorD(0, 0, 1))
left_torque.SetMforce(0.0005)

right_torque = chrono.ChForce()
wheel_right.AddForce(right_torque)
right_torque.SetMode(chrono.ChForce.TORQUE)
right_torque.SetRelDir(chrono.ChVectorD(0, 0, -1))
right_torque.SetMforce(0.0005)

right_wheels.append(wheel_right)
left_wheels.append(wheel_left)
right_torques.append(right_torque)
left_torques.append(left_torque)

my_ground = my_system.SearchBody('ground')
if not my_ground:
    sys.exit('Error: cannot find leg from its name in the C::E system!')
my_ground.SetMaterialSurface(material)

#------------------------------------
# Path controller
#------------------------------------
# Gains with linear control law
zeta=1
a=100
k2=a**2
k3=2*zeta*a

# Desired path
thetaref=0 # Reference angle along entire path
ss=1

#------------------------------------
# Adaptive controller
#------------------------------------
k=(1e-2)*np.eye(2)
lambdaa=(1e-1)*np.eye(2)
a_hat=0*np.eye(5,1)
a_hatdot=a_hat
P= np.eye(5)


# create a path
length=100
st=np.zeros(length)

for i in range(length):
    st[i]=i/30
    
    
ax=np.zeros(length)
ay=np.zeros(length)

for i in range(length):
    ax[i]=st[i]
    ay[i]=np.sin(ax[i])

reference_path = Path(ax, ay)
s = np.arange(0, reference_path.length, 0.1)
goal=[ax[-1], ay[-1]]

e, k, thetaref, s0 = reference_path.calc_track_error(0, 0, 0.0)
#------------------------------------
# Robot Geometric Parameters
#------------------------------------
r = 0.016  # Wheel radius
b = 0.07324/2 # 1/2 Wheelbase
    
#  Create an Irrlicht application to visualize the system
myapplication = chronoirr.ChIrrApp(my_system, 'Test', chronoirr.dimension2du(1600,1200))
myapplication.AddTypicalSky(chrono.GetChronoDataPath() + 'skybox/')
myapplication.AddTypicalLogo(chrono.GetChronoDataPath() + 'logo_pychrono_alpha.png')
myapplication.AddTypicalCamera(chronoirr.vector3df(0,2,1.5),chronoirr.vector3df(0,0,0))
myapplication.AddTypicalLights()
myapplication.SetSymbolscale(0.02)
myapplication.SetShowInfos(True)
myapplication.SetContactsDrawMode(3)
myapplication.SetPaused(True)

#myapplication.AddLightWithShadow(chronoirr.vector3df(10,20,10),chronoirr.vector3df(0,2.6,0), 10 ,10,40, 60, 512);
myapplication.AssetBindAll();
myapplication.AssetUpdateAll();
myapplication.AddShadowAll();

#------------------------------------
# Run the simulation forever until windows is closed
#------------------------------------
myapplication.SetTimestep(m_timestep);

pos_dot_ref = np.array([0, 0, 0])
measure_torque_left = []
measure_torque_right = []
locations_x = []
locations_z = []
heading_angles=[]
times = []

des_pos_x = []
des_pos_z = []
des_headings = []
a_hats = []

current_heading= bot1.GetFrame_COG_to_abs().GetRotAngle()

theta_tilda= current_heading - thetaref

while(myapplication.GetDevice().run()):
    myapplication.BeginScene()
    myapplication.DrawAll()
    t = my_system.GetChTime()
    
 #   random_noise.SetF_x(chrono.ChFunction_Const(.05*np.random.rand()))
 #   random_noise.SetF_z(chrono.ChFunction_Const(.05*np.random.rand()))
    
    # Read current state
    # Heading angle
    q = reference.GetAbsFrame().GetRot()
    d2 = q.Rotate(chrono.ChVectorD(0,-1,0))
    d2v = np.array([d2.x, d2.z])
    d2v = d2v / np.linalg.norm(d2v)
    current_heading = np.arctan2(d2v[1],d2v[0])

    theta_tilda = current_heading - thetaref
    pos = np.array([bot1.GetPos().x, bot1.GetPos().z, current_heading])
    pos_dot = np.array([bot1.GetPos_dt().x, bot1.GetPos_dt().z, -bot1.GetWvel_loc().y])
    
    v = math.sqrt(bot1.GetPos_dt().x**2+bot1.GetPos_dt().y**2+bot1.GetPos_dt().z**2)
    v_ref = 0.5
    l, k, theta_ref, s0 = reference_path.calc_track_error(pos[0], pos[1], s0)
    #------------------------------------
    # Update Path controller state
    #------------------------------------
    
    # Linear feedback law
    u=(-k3*abs(v_ref)*theta_tilda -k2*v_ref*l  )
        
    theta_tilda_dot = u


    #print("u= "+str(u))
    
    if t>.5:
        #------------------------------------
        # Adaptive controller
        #------------------------------------
        
#        # Desired location, velocity, acceleration (wheels)
        q_d_dot = np.matmul(np.array([[1./r,b/r],[1./r, -b/r]]),np.array([[-v_ref],[u]]))
        print(q_d_dot)
#        q_d_dotdot = np.matmul(np.array([[1/r,b/r],[1/r, -b/r]]),np.array([[math.sqrt(pos_dotdot_ref[0]**2+pos_dotdot_ref[1]**2)],[pos_dotdot_ref[2]]]))
#        
#        # Convert current speed to wheel velocities
#        q_dot = np.matmul(np.array([[1./r,b/r],[1./r, -b/r]]),np.array([[v],[pos_dot[2]]]))
#        

        # Set the wheel velocities
        wheel_right.SetWvel_loc(chrono.ChVectorD(0,0,q_d_dot[0][0]))
        wheel_left.SetWvel_loc(chrono.ChVectorD(0,0,-q_d_dot[1][0]))
        
        # Store values
#        measure_torque_left.append(T[1][0])
#        measure_torque_right.append(T[0][0])
        locations_x.append(bot1.GetPos().x)
        locations_z.append(bot1.GetPos().z)
        heading_angles.append(current_heading)
        times.append(t)
        
        #des_pos_x.append(pos_ref[0])
        #des_pos_z.append(pos_ref[1])
        #des_headings.append(pos_ref[2])
        
        a_hats.append(a_hat)
    
    myapplication.DoStep()
    myapplication.EndScene()


plt.figure(1)
plt.plot(locations_x, locations_z,color='b',label='path_traveled')
#q=ax.quiver(locations_x[0:-1:50], locations_z[0:-1:50], np.cos(heading_angles)[0:-1:50], np.sin(heading_angles)[0:-1:50])
plt.plot(ax,ay,color='g',linestyle='dashed',label='desired_path')
plt.xlabel("x")
plt.ylabel("y")
plt.grid(True)
plt.title('path of robot')
plt.legend()  
plt.show()



