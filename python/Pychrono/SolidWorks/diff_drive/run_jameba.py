#-------------------------------------------------------------------------------
# Name:        	run_jameba.py
# Purpose:	Modular combined controller for JAMEBA
#
# Author:      	Qiyuan Zhou
#-------------------------------------------------------------------------------
#!/usr/bin/env python

def main():
    pass

if __name__ == '__main__':
    main()


import os
import math
import time
import sys, getopt
import pychrono as chrono
import pychrono.postprocess as postprocess
import pychrono.irrlicht as chronoirr
import numpy as np
import matplotlib.pyplot as plt


# ---------------------------------------------------------------------
#
# Parse command-line parameters

m_filename = "jameba2.py"
m_timestep = 0.001
m_length = 1.0
m_datapath = "C:/Program Files/ChronoSolidworks/data/"

try:
	opts, args = getopt.getopt(sys.argv[1:],"f:d:T:v:p:",["filename=","timestep=","Tlength=","visualization=","datapath="])
except getopt.GetoptError:
	#print ("run_test.py -f <filename> [-d <timestep> -T <length> -v <pov|irrlicht> -p <chronodatapath>]")
	sys.exit(2)
for opt, arg in opts:
	print ("opt:", opt, "  arg", arg)
	if   opt in ("-d", "--timestep"):
		m_timestep = float(arg)
	elif opt in ("-T", "--Tlength"):
		m_length = float(arg)
	elif opt in ("-f", "--filename"):
		m_filename = arg
	elif opt in ("-v", "--visualization"):
		m_visualization = arg
	elif opt in ("-p", "--datapath"):
		m_datapath = arg
		
if m_filename == "":
	print ("run_test.py -f <filename> [-d <timestep> -T <length> -v <pov|irrlicht> -p <chronodatapath>]")
	sys.exit(2)

if not os.path.isfile(m_filename):
	print ("Error. Filename " + m_filename + " does not exist.")
	sys.exit(2)
    
chrono.SetChronoDataPath(m_datapath)

print ("  file to load is ", m_filename)
print ("  timestep is ", m_timestep)
print ("  length is ", m_length)
print ("  data path for fonts etc.: ", m_datapath)


# ---------------------------------------------------------------------
#
#  load the file generated by the SolidWorks CAD plugin
#  and add it to the ChSystem.
#

# Remove the trailing .py and add / in case of file without ./
m_absfilename = os.path.abspath(m_filename)
m_modulename = os.path.splitext(m_absfilename)[0]

#print ("Loading C::E scene...");

exported_items = chrono.ImportSolidWorksSystem(m_modulename)

#print ("...loading done!");


## Print exported items
#for my_item in exported_items:
#	print (my_item.GetName())

# Add items to the physical system
my_system = chrono.ChSystemNSC()
for my_item in exported_items:
	my_system.Add(my_item)
		
		
# Optionally set some solver parameters.
   
my_system.SetSolverTolerance(1e-9)
my_solver = chrono.ChSolverBB()
my_system.SetSolver(my_solver)
my_solver.SetMaxIterations(150)
my_system.SetTimestepperType(1) # Euler Implicit Projected
#my_solver.EnableWarmStart(True);
my_system.Set_G_acc(chrono.ChVectorD(0,-9.81,0))
chrono.ChCollisionModel_SetDefaultSuggestedEnvelope(0.001)

# Default Material
material = chrono.ChMaterialSurfaceNSC()
material.SetFriction(0.2)
#material.SetDampingF(0.1)
material.SetCompliance(0.00001)

# Tire Material
tire_mat = chrono.ChMaterialSurfaceNSC()
tire_mat.SetFriction(0.8)
#tire_mat.SetDampingF(0.05)
tire_mat.SetCompliance(0.00001)

# Set materials for interior particles
for i in range(1,26):
    passive_interior = my_system.SearchBody('interior-' +str(i))
    passive_interior.SetMaterialSurface(material)
    passive_interior.SetMass(0.0005)

# Empty vectors to store wheel, torque, marker objects
right_wheels = []
left_wheels = []

right_torques = []
left_torques = []

right_markers = []
left_markers = []

bots = []

bot_numbers = [1,4,5,7,8]   # Thanks stupid naming scheme in Solidworks

torque_mag = 0.00

# Bot 1
bot1 = my_system.SearchBody('_bot-1')
wheel_left = my_system.SearchBody('wheel-1')
wheel_right = my_system.SearchBody('wheel-2')
wheel_left.SetMaterialSurface(tire_mat)
wheel_right.SetMaterialSurface(tire_mat)

if not wheel_left or not wheel_right:
    sys.exit('Error: cannot find wheel from its name in the C::E system!')
    
left_torque = chrono.ChForce()
wheel_left.AddForce(left_torque)
left_torque.SetMode(chrono.ChForce.TORQUE)
left_torque.SetRelDir(chrono.ChVectorD(0, 0, 1))
left_torque.SetMforce(torque_mag)

right_torque = chrono.ChForce()
wheel_right.AddForce(right_torque)
right_torque.SetMode(chrono.ChForce.TORQUE)
right_torque.SetRelDir(chrono.ChVectorD(0, 0, -1))
right_torque.SetMforce(torque_mag)

right_wheels.append(wheel_right)
left_wheels.append(wheel_left)
right_torques.append(right_torque)
left_torques.append(left_torque)

bots.append(bot1)
#my_leg.SetMaterialSurface(material)


# Bot 4
bot4 = my_system.SearchBody('_bot-4')
wheel_left = my_system.SearchBody('wheel-6')
wheel_right = my_system.SearchBody('wheel-15')
wheel_left.SetMaterialSurface(tire_mat)
wheel_right.SetMaterialSurface(tire_mat)

if not wheel_left or not wheel_right:
    sys.exit('Error: cannot find wheel from its name in the C::E system!')
    
left_torque = chrono.ChForce()
wheel_left.AddForce(left_torque)
left_torque.SetMode(chrono.ChForce.TORQUE)
left_torque.SetRelDir(chrono.ChVectorD(0, 0, 1))
left_torque.SetMforce(torque_mag)

right_torque = chrono.ChForce()
wheel_right.AddForce(right_torque)
right_torque.SetMode(chrono.ChForce.TORQUE)
right_torque.SetRelDir(chrono.ChVectorD(0, 0, -1))
right_torque.SetMforce(torque_mag)

right_wheels.append(wheel_right)
left_wheels.append(wheel_left)
right_torques.append(right_torque)
left_torques.append(left_torque)
bots.append(bot4)

# Bot 5
bot5 = my_system.SearchBody('_bot-5')
wheel_left = my_system.SearchBody('wheel-8')
wheel_right = my_system.SearchBody('wheel-14')
wheel_left.SetMaterialSurface(tire_mat)
wheel_right.SetMaterialSurface(tire_mat)

if not wheel_left or not wheel_right:
    sys.exit('Error: cannot find wheel from its name in the C::E system!')
    
left_torque = chrono.ChForce()
wheel_left.AddForce(left_torque)
left_torque.SetMode(chrono.ChForce.TORQUE)
left_torque.SetRelDir(chrono.ChVectorD(0, 0, 1))
left_torque.SetMforce(torque_mag)

right_torque = chrono.ChForce()
wheel_right.AddForce(right_torque)
right_torque.SetMode(chrono.ChForce.TORQUE)
right_torque.SetRelDir(chrono.ChVectorD(0, 0, -1))
right_torque.SetMforce(torque_mag)

right_wheels.append(wheel_right)
left_wheels.append(wheel_left)
right_torques.append(right_torque)
left_torques.append(left_torque)
bots.append(bot5)

# Bot 7
bot7 = my_system.SearchBody('_bot-7')
wheel_left = my_system.SearchBody('wheel-7')
wheel_right = my_system.SearchBody('wheel-12')
wheel_left.SetMaterialSurface(tire_mat)
wheel_right.SetMaterialSurface(tire_mat)

if not wheel_left or not wheel_right:
    sys.exit('Error: cannot find wheel from its name in the C::E system!')
    
left_torque = chrono.ChForce()
wheel_left.AddForce(left_torque)
left_torque.SetMode(chrono.ChForce.TORQUE)
left_torque.SetRelDir(chrono.ChVectorD(0, 0, 1))
left_torque.SetMforce(torque_mag)

right_torque = chrono.ChForce()
wheel_right.AddForce(right_torque)
right_torque.SetMode(chrono.ChForce.TORQUE)
right_torque.SetRelDir(chrono.ChVectorD(0, 0, -1))
right_torque.SetMforce(torque_mag)

right_wheels.append(wheel_right)
left_wheels.append(wheel_left)
right_torques.append(right_torque)
left_torques.append(left_torque)
bots.append(bot7)

# Bot 8
bot8 = my_system.SearchBody('_bot-8')
wheel_left = my_system.SearchBody('wheel-5')
wheel_right = my_system.SearchBody('wheel-13')
wheel_left.SetMaterialSurface(tire_mat)
wheel_right.SetMaterialSurface(tire_mat)

if not wheel_left or not wheel_right:
    sys.exit('Error: cannot find wheel from its name in the C::E system!')
    
left_torque = chrono.ChForce()
wheel_left.AddForce(left_torque)
left_torque.SetMode(chrono.ChForce.TORQUE)
left_torque.SetRelDir(chrono.ChVectorD(0, 0, 1))
left_torque.SetMforce(torque_mag)

right_torque = chrono.ChForce()
wheel_right.AddForce(right_torque)
right_torque.SetMode(chrono.ChForce.TORQUE)
right_torque.SetRelDir(chrono.ChVectorD(0, 0, -1))
right_torque.SetMforce(torque_mag)

right_wheels.append(wheel_right)
left_wheels.append(wheel_left)
right_torques.append(right_torque)
left_torques.append(left_torque)
bots.append(bot8)

my_ground = my_system.SearchBody('ground')
if not my_ground:
    sys.exit('Error: cannot find leg from its name in the C::E system!')
my_ground.SetMaterialSurface(tire_mat)

                                                                              
#  Create an Irrlicht application to visualize the system
myapplication = chronoirr.ChIrrApp(my_system, 'Test', chronoirr.dimension2du(1600,1200))
myapplication.AddTypicalSky(chrono.GetChronoDataPath() + 'skybox/')
myapplication.AddTypicalLogo(chrono.GetChronoDataPath() + 'logo_pychrono_alpha.png')
myapplication.AddTypicalCamera(chronoirr.vector3df(0,2,1.5),chronoirr.vector3df(0,0,0))
myapplication.AddTypicalLights()
myapplication.SetSymbolscale(0.02)
myapplication.SetShowInfos(True)
myapplication.SetContactsDrawMode(3)
myapplication.SetPaused(True)

myapplication.AddLightWithShadow(chronoirr.vector3df(10,20,10),chronoirr.vector3df(0,2.6,0), 10 ,10,40, 60, 512);
myapplication.AssetBindAll();
myapplication.AssetUpdateAll();
myapplication.AddShadowAll();

# Empty matrices for plotting
leader_xs = []
leader_zs = []
coms_x = []
coms_z = []
leader_headings=[]
times = []

#------------------------------------
# Robot Geometric Parameters
#------------------------------------
r = 0.016  # Wheel radius
b = 0.07324/2 # 1/2 Wheelbase

# Common Controller references
v_ref = 1.5
omega_r=180*np.pi/180

#------------------------------------
# Path controller
#------------------------------------
leader = 1 # Index for leader bot

# Gains with linear control law
zeta=1
a=10
k2=a**2
k3=2*zeta*a

# Desired path
thetaref=0 # Reference angle along entire path
ss=1

# Initialize some parameters
l = bots[leader].GetPos().x  -0.2  # Signed distance between P and P
leader_pos_dot_ref = np.array([0, 0, 0])
followers = [x for i,x in enumerate(bots) if i!=leader]
followers_l = [x for i,x in enumerate(left_wheels) if i!=leader]
followers_r = [x for i,x in enumerate(right_wheels) if i!=leader]

#------------------------------------
# Pose controller
#------------------------------------
# Nonlinear Controller
k1_pose=1
k2_pose=3

# Update pose for followers this many time steps in advance
pose_update = 10

#------------------------------------
# Run the simulation forever until windows is closed
#------------------------------------
myapplication.SetTimestep(m_timestep);

	
while(myapplication.GetDevice().run()):
    myapplication.BeginScene()
    myapplication.DrawAll()
    t = my_system.GetChTime()
    #------------------------------------
    # Path controller
    #------------------------------------
    
    # Heading
    reference = bots[leader].SearchMarker('right_marker')
    q = reference.GetAbsFrame().GetRot()
    d2 = q.Rotate(chrono.ChVectorD(0,-1,0))
    d2v = np.array([d2.x, d2.z])
    d2v = d2v / np.linalg.norm(d2v)
    leader_heading = np.arctan2(d2v[1],d2v[0])
    
    # Read current state
    leader_theta_tilda = leader_heading - thetaref
    leader_pos = np.array([bots[leader].GetPos().x, bots[leader].GetPos().z, leader_heading])
    leader_pos_dot = np.array([bots[leader].GetPos_dt().x, bots[leader].GetPos_dt().z, -bots[leader].GetWvel_loc().y])
    leader_v = math.sqrt(bots[leader].GetPos_dt().x**2+bots[leader].GetPos_dt().y**2+bots[leader].GetPos_dt().z**2)
    
    # Update Path controller state
    
    # Linear feedback law
    u=(-k3*abs(v_ref)*leader_theta_tilda -k2*v_ref*l)
    
    #print("theta_tilda= "+str(leader_theta_tilda))
    #print("l= "+str(l))
    
    # Rates of change
    ss_dot = v_ref*np.cos(leader_theta_tilda)
    l_dot = v_ref*np.sin(leader_theta_tilda)
    leader_theta_tilda_dot = u
    #print("u= "+str(u))
    
    # Integrate to get new values
    ss = ss + ss_dot*m_timestep
    l = l + l_dot*m_timestep
    leader_theta_tilda = leader_theta_tilda + leader_theta_tilda_dot*m_timestep
    
    # Update ref velocities and positions and accelerations on path  
    leader_prev_pos_dot_ref = leader_pos_dot_ref
    leader_pos_dot_ref = np.array([v_ref*np.cos(leader_theta_tilda+thetaref), v_ref*np.sin(leader_theta_tilda+thetaref), leader_theta_tilda_dot])
    leader_pos_ref = leader_pos + leader_pos_dot_ref*m_timestep
    leader_pos_dotdot_ref = (leader_pos_dot_ref-leader_prev_pos_dot_ref)/m_timestep
    
    # Desired location, velocity, acceleration (wheels)
    q_d_dot = np.matmul(np.array([[1./r,b/r],[1./r, -b/r]]),np.array([[-v_ref],[u]]))
    
#    for i in range(5):
    # Set the wheel velocities
    right_wheels[leader].SetWvel_loc(chrono.ChVectorD(0,0,q_d_dot[0][0]))
    left_wheels[leader].SetWvel_loc(chrono.ChVectorD(0,0,-q_d_dot[1][0]))
    
    leader_xs.append(bots[leader].GetPos().x)
    leader_zs.append(bots[leader].GetPos().z)
    leader_headings.append(leader_heading)
    times.append(t)
    
    # Find robot center
    tempx = leader_pos[0]
    tempz = leader_pos[1]
    for robot in followers:
        tempx += robot.GetPos().x
        tempz += robot.GetPos().z
    com_x = tempx/(len(followers)+1)
    com_z = tempz/(len(followers)+1)
    coms_x.append(com_x)
    coms_z.append(com_z)
    
    #------------------------------------
    # Pose Controller
    #------------------------------------
    
    if round(t,2)%(m_timestep*pose_update) < 1e-3:
        counter=0
        for i in followers:
            # Heading angle
            reference = i.SearchMarker('right_marker')
            q = reference.GetAbsFrame().GetRot()
            d2 = q.Rotate(chrono.ChVectorD(0,-1,0))
            d2v = np.array([d2.x, d2.z])
            d2v = d2v / np.linalg.norm(d2v)
            heading = np.arctan2(d2v[1],d2v[0])
            
            #Update current position and references
            z = np.array([[i.GetPos().x], [i.GetPos().z], [heading]])
            z_r = z + np.array([[leader_pos_dot_ref[0]],[leader_pos_dot_ref[1]],[leader_pos_dot_ref[2]]]) * m_timestep * 10 * pose_update
            z_r[2]=leader_heading
            
            # Transform Coordinates
            targ_vect = z_r[0:2:1]-z[0:2:1]
            targ_dist = np.linalg.norm(targ_vect)
            targ_vect = targ_vect/np.linalg.norm(targ_vect)
            targ_ang = np.arctan2(targ_vect[1],targ_vect[0])[0]
            delta = heading - targ_ang
            theta = z_r[2][0] - np.arctan2((z_r[1][0]-z[1][0]),(z_r[0][0]-z[0][0]))
            
            # Control Law
            if targ_dist < 0.05:
                k1_p=0
                v_r=v_ref/10
            else:
                k1_p=k1_pose
                v_r=v_ref
            w = (-v_r/targ_dist) * (k2_pose*(delta-np.arctan(-k1_p*theta))+(1+(k1_p/(1+(k1_p*theta)**2)))*np.sin(delta))
            u = np.array([[-v_r],[w]])
            
            # Desired wheel velocities
            des_vel_right = u[0][0]/r + b*u[1][0]/r
            des_vel_left = u[0][0]/r - b*u[1][0]/r
            print("counter= "+str(counter))
            print("time= "+str(t))
            print("desired left= "+str(des_vel_left))
            print("desired right= "+str(des_vel_right))
            
            # Set the wheel velocities
            followers_r[counter].SetWvel_loc(chrono.ChVectorD(0,0,des_vel_right))
            followers_l[counter].SetWvel_loc(chrono.ChVectorD(0,0,-des_vel_left))
                        
            counter = counter + 1

    myapplication.DoStep()
    myapplication.EndScene()

# Plot the leader's path
fig, ax = plt.subplots()
ax.plot(leader_xs, leader_zs)
q=ax.quiver(leader_xs[0:-1:50], leader_zs[0:-1:50], np.cos(leader_headings)[0:-1:50], np.sin(leader_headings)[0:-1:50])
ax.set(xlabel='x', ylabel='y', title='Leader Positions')
ax.grid()
ax.axis('equal')
plt.show()

# Plot the COM path
fig, ax = plt.subplots()
ax.plot(coms_x, coms_z)
q=ax.quiver(coms_x[0:-1:50], coms_z[0:-1:50], np.cos(leader_headings)[0:-1:50], np.sin(leader_headings)[0:-1:50])
ax.set(xlabel='x', ylabel='y', title='COM Position')
ax.grid()
ax.axis('equal')
plt.show()
