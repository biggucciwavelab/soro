#-------------------------------------------------------------------------------
# Name:        	run_diff_path.py
# Purpose:	Path controller for differential drive robot
#
# Author:      	Qiyuan Zhou
#-------------------------------------------------------------------------------
#!/usr/bin/env python

def main():
    pass

if __name__ == '__main__':
    main()


import os
import math
import time
import sys, getopt
import pychrono as chrono
import pychrono.postprocess as postprocess
import pychrono.irrlicht as chronoirr
import numpy as np
import matplotlib
import matplotlib.pyplot as plt

# ---------------------------------------------------------------------
# Parse command-line parameters

m_filename = "diff.py"
m_timestep = 0.001
m_length = 1.0
m_visualization = "irrlicht"
m_datapath = "C:/Program Files/ChronoSolidworks/data/"

#try:
#	opts, args = getopt.getopt(sys.argv[1:],"f:d:T:v:p:",["filename=","timestep=","Tlength=","visualization=","datapath="])
#except getopt.GetoptError:
#	#print ("run_test.py -f <filename> [-d <timestep> -T <length> -v <pov|irrlicht> -p <chronodatapath>]")
#	sys.exit(2)
#for opt, arg in opts:
#	print ("opt:", opt, "  arg", arg)
#	if   opt in ("-d", "--timestep"):
#		m_timestep = float(arg)
#	elif opt in ("-T", "--Tlength"):
#		m_length = float(arg)
#	elif opt in ("-f", "--filename"):
#		m_filename = arg
#	elif opt in ("-v", "--visualization"):
#		m_visualization = arg
#	elif opt in ("-p", "--datapath"):
#		m_datapath = arg
#		
#if m_filename == "":
#	print ("run_test.py -f <filename> [-d <timestep> -T <length> -v <pov|irrlicht> -p <chronodatapath>]")
#	sys.exit(2)
#
#if not os.path.isfile(m_filename):
#	print ("Error. Filename " + m_filename + " does not exist.")
#	sys.exit(2)
#    
#chrono.SetChronoDataPath(m_datapath)
#
#print ("  file to load is ", m_filename)
#print ("  timestep is ", m_timestep)
#print ("  length is ", m_length)
#print ("  data path for fonts etc.: ", m_datapath)
## ---------------------------------------------------------------------
##
##  load the file generated by the SolidWorks CAD plugin
##  and add it to the ChSystem.
##

# Remove the trailing .py and add / in case of file without ./
m_absfilename = os.path.abspath(m_filename)
m_modulename = os.path.splitext(m_absfilename)[0]
#print ("Loading C::E scene...");
exported_items = chrono.ImportSolidWorksSystem(m_modulename)
#print ("...loading done!");

# Print exported items
#for my_item in exported_items:
#	print (my_item.GetName())

# Add items to the physical system
my_system = chrono.ChSystemNSC()
# Colors
col_y = chrono.ChColorAsset()
col_y.SetColor(chrono.ChColor(0.44, .11, 52))
exported_items[1].AddAsset(col_y)

for my_item in exported_items:
	my_system.Add(my_item)
		
# Optionally set some solver parameters.
#timestepper = chrono.ChTimestepperEulerImplicitProjected()
my_system.SetSolverTolerance(1e-10)
my_solver = chrono.ChSolverBB()
my_system.SetSolver(my_solver)
my_solver.SetMaxIterations(200)
my_system.SetTimestepperType(1) # Euler Implicit Projected
my_solver.EnableWarmStart(True);
my_system.Set_G_acc(chrono.ChVectorD(0,-9.81,0))
chrono.ChCollisionModel_SetDefaultSuggestedEnvelope(0.001)
chrono.ChCollisionModel_SetDefaultSuggestedMargin(0.001)

# Default Material
material = chrono.ChMaterialSurfaceNSC()
material.SetFriction(0.4)
material.SetDampingF(0.)
material.SetCompliance(0.00001)

# Tire Material
tire_mat = chrono.ChMaterialSurfaceNSC()
tire_mat.SetFriction(0.8)
tire_mat.SetDampingF(0.)
tire_mat.SetCompliance(0.00001)

# Empty vectors to store wheel, torque, marker objects
right_wheels = []
left_wheels = []

right_torques = []
left_torques = []

right_markers = []
left_markers = []

bot_numbers = [1,4,5,7,8]   # Thanks stupid naming scheme in Solidworks

# Bot 1
bot1 = my_system.SearchBody('_bot-1')
wheel_left = my_system.SearchBody('wheel-1')
wheel_right = my_system.SearchBody('wheel-2')
bot1.AddAsset(col_y)
reference = bot1.SearchMarker('right_marker')
random_noise = chrono.ChForce()
bot1.AddForce(random_noise)
random_noise.SetMode(chrono.ChForce.FORCE)

if not wheel_left or not wheel_right:
    sys.exit('Error: cannot find wheel from its name in the C::E system!')
    
left_torque = chrono.ChForce()
wheel_left.AddForce(left_torque)
left_torque.SetMode(chrono.ChForce.TORQUE)
left_torque.SetRelDir(chrono.ChVectorD(0, 0, 1))
left_torque.SetMforce(0.0005)

right_torque = chrono.ChForce()
wheel_right.AddForce(right_torque)
right_torque.SetMode(chrono.ChForce.TORQUE)
right_torque.SetRelDir(chrono.ChVectorD(0, 0, -1))
right_torque.SetMforce(0.0005)

right_wheels.append(wheel_right)
left_wheels.append(wheel_left)
right_torques.append(right_torque)
left_torques.append(left_torque)

my_ground = my_system.SearchBody('ground')
if not my_ground:
    sys.exit('Error: cannot find leg from its name in the C::E system!')
my_ground.SetMaterialSurface(material)

#------------------------------------
# Path controller
#------------------------------------
# Gains with linear control law
zeta=1
a=10
k2=a**2
k3=2*zeta*a

# Desired path
thetaref=0 # Reference angle along entire path
ss=1

#------------------------------------
# Adaptive controller
#------------------------------------
k=(1e-2)*np.eye(2)
lambdaa=(1e-1)*np.eye(2)
a_hat=0*np.eye(5,1)
a_hatdot=a_hat
P= np.eye(5)

#------------------------------------
# Robot Geometric Parameters
#------------------------------------
r = 0.016  # Wheel radius
b = 0.07324/2 # 1/2 Wheelbase
    
#  Create an Irrlicht application to visualize the system
myapplication = chronoirr.ChIrrApp(my_system, 'Test', chronoirr.dimension2du(1600,1200))
myapplication.AddTypicalSky(chrono.GetChronoDataPath() + 'skybox/')
myapplication.AddTypicalLogo(chrono.GetChronoDataPath() + 'logo_pychrono_alpha.png')
myapplication.AddTypicalCamera(chronoirr.vector3df(0,2,1.5),chronoirr.vector3df(0,0,0))
myapplication.AddTypicalLights()
myapplication.SetSymbolscale(0.02)
myapplication.SetShowInfos(True)
myapplication.SetContactsDrawMode(3)
myapplication.SetPaused(True)

#myapplication.AddLightWithShadow(chronoirr.vector3df(10,20,10),chronoirr.vector3df(0,2.6,0), 10 ,10,40, 60, 512);
myapplication.AssetBindAll();
myapplication.AssetUpdateAll();
myapplication.AddShadowAll();

#------------------------------------
# Run the simulation forever until windows is closed
#------------------------------------
myapplication.SetTimestep(m_timestep);

pos_dot_ref = np.array([0, 0, 0])
measure_torque_left = []
measure_torque_right = []
locations_x = []
locations_z = []
heading_angles=[]
times = []

des_pos_x = []
des_pos_z = []
des_headings = []
a_hats = []

current_heading= bot1.GetFrame_COG_to_abs().GetRotAngle()
l = bot1.GetPos().x - 0.5    # Signed distance between P and P
theta_tilda= current_heading - thetaref

while(myapplication.GetDevice().run()):
    myapplication.BeginScene()
    myapplication.DrawAll()
    t = my_system.GetChTime()
    
    random_noise.SetF_x(chrono.ChFunction_Const(.05*np.random.rand()))
    random_noise.SetF_z(chrono.ChFunction_Const(.05*np.random.rand()))
    
    # Read current state
    # Heading angle
    q = reference.GetAbsFrame().GetRot()
    d2 = q.Rotate(chrono.ChVectorD(0,-1,0))
    d2v = np.array([d2.x, d2.z])
    d2v = d2v / np.linalg.norm(d2v)
    current_heading = np.arctan2(d2v[1],d2v[0])

    theta_tilda = current_heading - thetaref
    pos = np.array([bot1.GetPos().x, bot1.GetPos().z, current_heading])
    pos_dot = np.array([bot1.GetPos_dt().x, bot1.GetPos_dt().z, -bot1.GetWvel_loc().y])
    
    v = math.sqrt(bot1.GetPos_dt().x**2+bot1.GetPos_dt().y**2+bot1.GetPos_dt().z**2)
    v_ref = 0.5
    
    #------------------------------------
    # Update Path controller state
    #------------------------------------
    
    # Linear feedback law
    u=(-k3*abs(v_ref)*theta_tilda -k2*v_ref*l )
    print(u)
    # Rates of change
    ss_dot = v_ref*np.cos(theta_tilda)
    l_dot = v_ref*np.sin(theta_tilda)
    theta_tilda_dot = u
    '''
    
    # Nonlinear feedback law
    ss_dot = 
    l_dot = 
    theta_tilda_dot =
    '''
    # Integrate to get new values
    ss = ss + ss_dot*m_timestep
    l = l + l_dot*m_timestep
    theta_tilda = theta_tilda + theta_tilda_dot*m_timestep
    
    # Update ref velocities and positions and accelerations on path  
    prev_pos_dot_ref = pos_dot_ref
    pos_dot_ref = np.array([v_ref*np.cos(theta_tilda+thetaref), v_ref*np.sin(theta_tilda+thetaref), theta_tilda_dot])
    pos_ref = pos + pos_dot_ref*m_timestep
    pos_dotdot_ref = (pos_dot_ref-prev_pos_dot_ref)/m_timestep
    
    #print("u= "+str(u))
    
    if t>.5:
        #------------------------------------
        # Adaptive controller
        #------------------------------------
        
        # Desired location, velocity, acceleration (wheels)
        q_d_dot = np.matmul(np.array([[1./r,b/r],[1./r, -b/r]]),np.array([[-v_ref],[u]]))
        q_d_dotdot = np.matmul(np.array([[1/r,b/r],[1/r, -b/r]]),np.array([[math.sqrt(pos_dotdot_ref[0]**2+pos_dotdot_ref[1]**2)],[pos_dotdot_ref[2]]]))
        
        # Convert current speed to wheel velocities
        q_dot = np.matmul(np.array([[1./r,b/r],[1./r, -b/r]]),np.array([[v],[pos_dot[2]]]))
        
        # Error Terms
        q_tilda = np.array([[0],[0]])
        q_tilda_dot = (q_dot-q_d_dot)
        q_r_dot = q_d_dot-np.matmul(lambdaa,q_tilda)
        q_r_dotdot = q_d_dotdot-np.matmul(lambdaa,q_tilda_dot)
        
        # Y terms
        y11= q_r_dotdot[0][0]
        y12= q_r_dotdot[1][0]
        y13= u*q_r_dot[1][0]
        y14= q_r_dot[0][0]
        y15= 0
        
        y21= q_r_dotdot[1][0]
        y22= q_r_dotdot[0][0]
        y23= -u*q_r_dot[0][0]
        y24= 0
        y25= q_r_dot[1][0]
        Y = np.array([[y11,y12,y13,y14,y15],[y21,y22,y23,y24,y25]])
        
        # Sliding Terms
        s = q_dot-q_r_dot
        a_hatdot = -1*np.matmul(P,np.matmul(np.transpose(Y),s))
        a_hat += a_hatdot*m_timestep
        
        # Torque terms
        T=(1e-4)*(np.matmul(Y,a_hat)-np.matmul(k,s))
        '''
        # Apply the torque
        left_torque.SetMforce(-T[1][0])
        right_torque.SetMforce(T[0][0])
        '''
        # Set the wheel velocities
        wheel_right.SetWvel_loc(chrono.ChVectorD(0,0,q_d_dot[0][0]))
        wheel_left.SetWvel_loc(chrono.ChVectorD(0,0,-q_d_dot[1][0]))
        
        # Store values
        measure_torque_left.append(T[1][0])
        measure_torque_right.append(T[0][0])
        locations_x.append(bot1.GetPos().x)
        locations_z.append(bot1.GetPos().z)
        heading_angles.append(current_heading)
        times.append(t)
        
        des_pos_x.append(pos_ref[0])
        des_pos_z.append(pos_ref[1])
        des_headings.append(pos_ref[2])
        
        a_hats.append(a_hat)
    
    myapplication.DoStep()
    myapplication.EndScene()

# Plot the wheel torques
fig, axs = plt.subplots(2)
fig.suptitle('Wheel Torques')
axs[0].plot(times, measure_torque_left)
axs[1].plot(times, measure_torque_right)

# Plot the path
fig, ax = plt.subplots()
ax.plot(locations_x, locations_z)
q=ax.quiver(locations_x[0:-1:50], locations_z[0:-1:50], np.cos(heading_angles)[0:-1:50], np.sin(heading_angles)[0:-1:50])
ax.set(xlabel='x', ylabel='y', title='Actual Positions')
ax.grid()
ax.axis('equal')
plt.show()

# Plot the desired path
fig, ax = plt.subplots()
ax.plot(des_pos_x, des_pos_z)
q=ax.quiver(des_pos_x[0:-1:50], des_pos_z[0:-1:50], np.cos(des_headings)[0:-1:50], np.sin(des_headings)[0:-1:50])
ax.set(xlabel='x', ylabel='y', title='Desired Positions')
ax.grid()
ax.axis('equal')
plt.show()

